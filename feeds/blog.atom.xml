<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Opinionated Guides - Blog</title><link href="https://opinionatedguide.github.io/" rel="alternate"></link><link href="https://opinionatedguide.github.io/feeds/blog.atom.xml" rel="self"></link><id>https://opinionatedguide.github.io/</id><updated>2019-10-14T12:02:23-05:00</updated><entry><title>The 4400 (watts)</title><link href="https://opinionatedguide.github.io/The%204400%20(watts).html" rel="alternate"></link><published>2019-07-29T13:33:29-05:00</published><updated>2019-08-01T16:38:53-05:00</updated><author><name>Vega Deftwing</name></author><id>tag:opinionatedguide.github.io,2019-07-29:/The 4400 (watts).html</id><summary type="html">&lt;p&gt;About six moths ago (approx February of '18) I decided to pursue a project to make it so I could run Linux or windows programs on the same system without issues... or at least as smoothly as possible. I had quite a few ways I knew I could go about …&lt;/p&gt;</summary><content type="html">&lt;p&gt;About six moths ago (approx February of '18) I decided to pursue a project to make it so I could run Linux or windows programs on the same system without issues... or at least as smoothly as possible. I had quite a few ways I knew I could go about doing this: Wine, VMs with GPU passthough, Bash-on-Windows, Cygwin, ... . However, I really didn't know which way I wanted to go about it. I eventually came to the conclusion that the majority of the Linux work I do can be run from a cli and what can't be I can probably get to run though Bash-On-Windows/ The Windows Subsystem for Linux and an xserver. To make a long story short I was wrong, and that solution was royally awful and I hated it. But I learned a whole hell of a lot in the process.&lt;/p&gt;
&lt;p&gt;I knew I needed a Linux server to run alongside my main windows system, and I was looking to actually get a real server because I wanted something I could learn enterprise level skills on as well comfortably host services with minimal down time, so I was on the hunt for a server. I shopped around a bit, and I just happened to stumble into what looked to me- someone who normally buys consumer gear- to be incredible: a 64 thread (4x 8C/16T CPU), 64Gb ECC DDR3 System for about \&lt;span class="math"&gt;\(400, and then 2 10Gbe cards and the cable to connect the systems for another \\)&lt;/span&gt;50. To me this sounded like the most glorious of overkill and like it could be a whole lot of fun, so after no where near enough consideration I pulled the trigger. I did leave one interesting spec unsaid though: it has 4, 1100W Power supplies. Now, I'm not dumb. I knew 2 of those were redundant, bringing us down to 2200W max, and then given the system was only running with 64Gb of RAM and not powering any insane pci-e gear in the back (except for the 10gbe network card, but meh), and then doing some napkin math I knew there was basically no way it would be drawing more than about 600W, so- not to bad right? I mean, I have a 750W PSU in my desktop, 600W can't be a big deal?&lt;/p&gt;
&lt;p&gt;Yeah. This is why getting a server when you still live with your parents can be a bad idea. I didn't pay the power bill, and I had no idea of the 'true cost' of power. Screw the responsibility, with great power comes great bills.&lt;/p&gt;
&lt;p&gt;It was this one spec that got me, so not even two months into owning this behemoth I was already looking into selling it. Thankfully I did, as well as the 2 10Gbe cards, and at a nice profit at that, but that's not the point of this post. The point is what I did learn. Well, if it wasn't clear already, I learned that power costs money (also that using that much power legitimately heats up a room), but I learned a lot of interesting things about 10gbe networking, running a server, and the benefits and costs of buying of used enterprise gear as well, so here goes.&lt;/p&gt;
&lt;h1 id="benefitscosts-of-buying-used-enterprise-gear"&gt;Benefits/costs of buying used enterprise gear&lt;/h1&gt;
&lt;p&gt;The first thing of note here is my god are the prices ripe. I got the 10Gbe cards for what looks to be a steal, the deal on that server - even with that much RAM and CPU horsepower- while good wasn't necessarily the deal of a lifetime. Server gear is a /lot/ less expensive than you'd think, and works really well. The main gotcha's appear to be in noise, power consumption, and configuration&lt;/p&gt;
&lt;p&gt;The noise point is probably the largest problem. With the R910, the noise was actually totally tolerable to be around; however, the power vault I bought to go with it... not so much. 4, 80mm(?) jet engines in the back drove me nuts. Thankfully I solved that problem by replacing the fans with 3, 140mm fans in the front, but that's a story for another post. I've also owned an R1950 Server, and it was just as loud and I couldn't do anything about that one.&lt;/p&gt;
&lt;p&gt;Power consumption is a topic I think I already stressed enough above, but it's worse than that. I actually kept the Powervault MD1000 and H700 card so I could add more storage to my desktop, but the Powervault uses about 75W even when I'm not doing anything... that's more than the vast majority of computers and that's just for storage. What I'm saying is the power consumption of this stuff can add up real fast. Be smart.&lt;/p&gt;
&lt;p&gt;Finally, configuration: I went in circles trying to lower the consumption on the R910 to no avail, and the BIOS had a lot of power options. The 10Gbe Card was a nightmare in some respects to actually get 10Gbe throughput, and dealing with a mixture of SAS and SATA drives in the Powervault got a bit interesting too. I'm not saying any of these should stop you, just be prepared to put time into learning how to do the thing. Furthermore, the enterprise-y-ness of this gear really shined here. For example, having the H700 in my desktop makes it take about 10x as long to boot as a result of the added BIOS.&lt;/p&gt;
&lt;p&gt;All of that aside, Consumer 10GbE cards are still well over $100, there's no other good way I could add as many drives as I did to my desktop as I did with the Powervault (to clarify, I moved the vault to my desktop after deciding I'd sell the server), and assuming I could afford the power, there's no way I could get that much compute with consumer gear without selling my soul.&lt;/p&gt;
&lt;h1 id="running-the-server"&gt;Running The Server&lt;/h1&gt;
&lt;p&gt;Ironically, I didn't get all that much out of this. I've been using Linux as my daily driver for 5+ years now, and in a way where my system is half PC and half server, so I already knew most of how to server. So I'll keep this section brief.&lt;/p&gt;
&lt;p&gt;Server Remote management is a thing- iDrac. Server's typically have the worst™ integrated GPUs, to the point where running even i3wm is painful. Just don't. Servers have weird specs- the R910 had 25w max power pci-e lanes. Why? Dell if I know. Servers start up so slow you may as well grab a sandwich while it thinks. Linux runs really well though, and I was able to basically use it just like every other linux system. This isn't really unexpected, just nice to know the difference in gear didn't matter; in fact, the gear was actually better supported in Linux than windows for things like the 10GbE card and and H700 storage card.&lt;/p&gt;
&lt;h1 id="10gbe-networking"&gt;10GbE networking&lt;/h1&gt;
&lt;p&gt;Because this isn't supposed to be a guide on how to use or set up 10GbE cards or networks, I'm not going to get into the specifics, but what I will say is that when it works it's incredible. Getting it to work wasn't easy. I think the consumer gear would behave differently, to the point of plugnplay, but this wasn't like that at all. Even getting the 10GbE card to run at 10GbE on the Windows/client side was like pulling teeth. Ironically, if the client was booted into Linux as was well and speeds were great with almost no setup. I'm by no means implying this experience to be universal (though it is probably true more often than not), but I do think that if you're going to be running this gear running a server OS (I'm considering even desktop installs of linux to be server in this sense) will make hardware and network config much, much easier. Also worth noting, 10GbE networks, by their nature, do some things differently and benefit from advanced setup, be it by changing the MTU, or by optimizing for single port vs all, it's just a lot of playing with settings. I think it has it's uses, and can open a lot of cool doors, but ultimately I think it should be carefully weighed weather the cost of the consumer gear is worth it to avoid the headache.&lt;/p&gt;
&lt;h1 id="final-thoughts"&gt;Final thoughts&lt;/h1&gt;
&lt;p&gt;The R910 was like 150lbs, and was royally awful to move up and down stairs. Don't. Just. Don't.&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="Blog"></category><category term="Engineering"></category><category term="Blog"></category></entry><entry><title>The Future of Human Computer Interfaces and How We Work</title><link href="https://opinionatedguide.github.io/The%20Future%20of%20Human%20Computer%20Interfaces%20and%20How%20We%20Work.html" rel="alternate"></link><published>2019-07-29T13:33:29-05:00</published><updated>2019-07-29T13:33:29-05:00</updated><author><name>Vega Deftwing</name></author><id>tag:opinionatedguide.github.io,2019-07-29:/The Future of Human Computer Interfaces and How We Work.html</id><summary type="html">&lt;p&gt;I'm going to start out with the pile of question's I asked myself as I wrote this.&lt;/p&gt;
&lt;p&gt;What do you see when you sit down to work? My guess is a desk pressed against a wall, maybe a few shelves, one, maybe two monitors in front of you, and a …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I'm going to start out with the pile of question's I asked myself as I wrote this.&lt;/p&gt;
&lt;p&gt;What do you see when you sit down to work? My guess is a desk pressed against a wall, maybe a few shelves, one, maybe two monitors in front of you, and a keyboard and mouse dominating the work area of your desk. How do you access information? Do you simply Google something and if it's not on the first page give up? How do you get ahold of experts when you have a question? How do you interpret results that you find? How do you store information you've collected? How do you filter information to get exactly what you're looking for?&lt;/p&gt;
&lt;p&gt;If your answers where typical at all, I don't think this is a good way to work. I think we, as individuals and as business need to invest more in our work spaces, probably well beyond what most people would even consider. I'm not talking about adding a third monitor or giving everyone an artistic environment. I'm talking about setting up a work environment that's conducive to productivity as instead of merely being the medium on which it takes place, the work environment should actively contribute to finding, accessing, retrieving/storing, consuming, and creating. - where data can be anything from art to documentation.&lt;/p&gt;
&lt;h2 id="finding-information"&gt;Finding Information&lt;/h2&gt;
&lt;p&gt;We've grow accustomed to the all knowing Google answering any request, and really, I don't see anything wrong with that. I even think anyone at Google that may read this will probably share some of this vision. I would very much like to see a world where data searching is context aware. For example, say I'm searching for a data sheet for an old vacuum tube and I have a schematic of an old amplifier open in another tab, I would love if the engine for finding this data saw the context, saw I was searching for that, and changed the label in the schematic into a link to this datasheet. Furthermore, it would be great if it crawled the web and finished finding datasheets and hot linking them, possibly well before I even even got to that page in the first place. Another point is the summery of information and omission of the irrelevant info. Say I were to look up bits in a byte, I don't necessarily need the historical context as to why bits are named bits and bytes, bytes, though even though I didn't search it, presenting that a nyble is 4 bits, and how to tell endinan-ness is more relevent, unless I had recently searched historical information or stated I wanted that explicitly. In my opinion we should be less concerned with finding relevant results and more concerned with  discarding the irrelevant, though making the verbose available.&lt;/p&gt;
&lt;p&gt;I also think that brining people together, potentially anonymously, based on search and knowledge could be extraordinary valuable. If as I'm looking up 'How to do X' and somebody else is looking up 'How to Do Y, an advanced topic from X' it would be fantastic if we could talk, albeit unobtrusively to the person being requested. It seems to me that searching is desperately lacking a social element and ranking system. How great would a simple reddit like upvote system on any given search be? What if browsers added a comment system that was hosted though some sort of distributed network and tied to each page so people could leave comments on any site regardless of functionality?&lt;/p&gt;
&lt;p&gt;I also think the boundaries of physical and digital should be more blurred. I'd love if I could set a book on my desk and search though it for an idea or concept by mere image recognition of the cover, or if it's an unknown book at least being able to digest any pages shown to it explicitly. Say a section was highlighted? It would be great if that were automatically added to a &lt;em&gt;personal journal file of sorts&lt;/em&gt; for future reference, especially if related data were automatically associated from online sources, or links made to people who are interested in similar subjects. The digital world doesn't have to be lonely pages indexed like a book, why are we treating it as such? Today each page can point to any other page in a beautiful web of recursively indexed information, where each topic has lines of association spanning such that no two pages are unconnected. Wikipedia sort of has the simplest form of this, but what if we had systems so capable of automatic understanding - not just tagging - of information that any new info could propagate though that web naturally. Social linkage to people in the same graph, even if anonymous, could help connect people that together, due to their very specific knowledge, drive man kind further. I should clarify to, I literally mean a web/graph, possibly in 3D, relating and indexing information, possibly like &lt;a href="http://wiki.polyfra.me/"&gt;this 3D representation of wikipedia&lt;/a&gt;. &lt;a href="http://www.wikiverse.io/"&gt;(or this one)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Wikivelse" src="https://opinionatedguide.github.io/blog/wikiverse.png"&gt;&lt;/p&gt;
&lt;h2 id="accessing-data"&gt;Accessing Data&lt;/h2&gt;
&lt;p&gt;So, even if all of this data is able to be interconnected, distributed, and hyper-hyperlinked, what good is it if to access it is anything but simple and intuitive, like reading a book. Obviously this overly linked system is something that people would need to get used to. Until the advent of the WWW we've read information linearly, page by page. The web has allowed this tree traversal style of navigation so that any missed topic can be reviewed, but generally this is a system where the tree only build down, to simpler information, from the current node. It seems weird to think about an algebra book where it suddenly references multidimensional calculus, but this is exactly what I'm implying. In my education there was uncountable times I had to learn something because 'it will be used later' with no explanation as to how or why. Linking back up the tree allows for information traversal in both directions, eliminating this problem.&lt;/p&gt;
&lt;p&gt;But that's still a bit of the 'finding' side of things, how should the information actually be accessed? I'm not advocating for the destruction of books by any means, but I do think the way we actually view and access this data is due for an upgrade. Sure our screens are progressively getting to be higher resolution and have better color and readability qualities- as OLED is breaking the no white text on black backgrounds rule- but I don't think this is enough. I think we need to actually fundamentally make a new type of viewing device that is more adaptable to different content styles. the 16x9 monitor needs to die, my suggestion, 24x18 (4x3), now hear me out, I'm envisioning a screen that is 2.5 of a normal monitor long, and twice as 'tall', though it's this height were the magic happens, I'm proposing the top half of the monitor be flat while the bottom half has a curve to it approaching about 45 degrees by the bottom lip, while the overall horizontal is still curved. This has the effect of basically the inside of a sphere for the bottom half and a simple curved wall on the top. This, purely anecdotally, seems to make sense to me as it would provide a good encompassing but non distorted view for video or images, while at the bottom proving a more natural angle for reading- when you read from your phone do you want it held in font of your face or lower and tilted? Exactly. Obviously I view this as being a touch screen to allow the navigation of the web of pages as well.&lt;/p&gt;
&lt;p&gt;Beyond this I think it's time we rethink our main input devices as well. Today we primarily use three input devices: Mouse, Keyboard, and a touchscreen. I recognize a few use a pen and tablet, but I don't see that catching on anytime soon, though as with any prediction, I may be wrong. I think we should retain a physical keyboard at frequent use terminals/computers as the tactile feedback of switches (&lt;a href="https://www.pcgamer.com/best-mechanical-switches-for-gaming/"&gt;not rubber dome&lt;/a&gt;) is something that can't be beaten, though I think we do need to rethink the shape, layout, and even way we use a keyboard. &lt;a href="http://careyryan.com/stenotype-can-we-type-much-faster/"&gt;Plenty of research&lt;/a&gt; has &lt;a href="https://pbs.twimg.com/profile_images/981584961433202688/W3yiTuVz_400x400.jpg"&gt;shown&lt;/a&gt; we have a better way, and I think it's time we start abandoning &lt;a href="https://www.youtube.com/watch?v=5Et9Z25pyz0"&gt;what we know&lt;/a&gt; to be inferior. I don't want to hammer this too much though. Furthermore, I think we need to standardize a mouse that actually has useful inputs. The &lt;a href="https://media.roccat.org/img/products/Tyon/designdetails/76055/all/design-detail-5-img1-tyon-v1.jpg"&gt;Roccat Tyon&lt;/a&gt;, with it's shark fin in the middle, and the &lt;a href="https://cf2.s3.souqcdn.com/item/2015/10/27/93/77/77/0/item_XL_9377770_10303435.jpg"&gt;Logitech Mx Master&lt;/a&gt; with the horizontal scroll have both done very innovative things to make something that is truly much better than a three button mouse, but I think combining these ideas into one great, standard mouse could be a game changer. I also think we need to use more of our body- our feet sit there doing nothing, but imagine &lt;a href="http://wiki.polyfra.me/"&gt;all the things&lt;/a&gt; we could control with two &lt;a href="https://arstechnica.com/gadgets/2015/01/want-high-end-flight-sim-pedals-put-500-in-a-polish-bank-account-and-contact-slaw/"&gt;analog pedals&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Another thing is natural interaction without a physical connection: think &lt;a href="https://www.leapmotion.com/"&gt;Leap Motion&lt;/a&gt; or &lt;a href="https://en.wikipedia.org/wiki/Kinect"&gt;Microsoft's Kinect&lt;/a&gt;. These systems I think have limited practical use, but given the necessity for depth sensing camera's in some of what I described above it's kind of a 'why not'. Furthermore, obvious motions like twisting a knob in the air to control volume are simply convenient. Also, complex 'digitally analog' controls such as color balance of a picture could be controlled in a way that doesn't distract the user with the actual values or knob positions, instead focusing on the raw creation.&lt;/p&gt;
&lt;p&gt;Physical controllers are also something I've debated the practicality of repeatedly, as usually they're single purpose, like a MIDI keyboard. I think these controllers, for those that use them frequently enough to justify it, should not be standardized and the form factor they use should be something where as many choices as possible are available; however, I think a much better universal protocol than MIDI, HID, OSC, etc. needs to be made. I think exposing a raw form of data in the OS that allows the protocol to be redesigned on the fly would allow for more general purpose uses of hardware, like how some people are using &lt;a href="http://midi2lightroom.com/index.php/en/introduction"&gt;midi controllers in Photoshop&lt;/a&gt; or &lt;a href="https://www.youtube.com/watch?v=wEeVMEzOmac"&gt;WiiMotes for projection mappin&lt;/a&gt;g. Nothing but good could come from making off label uses more available, particularly for the disabled.&lt;/p&gt;
&lt;p&gt;Another point is the idea of biohacking and body augmentation. Examples include implanted &lt;a href="https://dangerousthings.com/"&gt;RFID tags&lt;/a&gt; (which I actually have) and &lt;a href="https://dangerousthings.com/biomagnets/"&gt;magnets for sensing electromagnetic fields&lt;/a&gt;, though I think a lot of biohackers are missing the point. &lt;a href="https://www.youtube.com/watch?v=4c1lqFXHvqI"&gt;This&lt;/a&gt; is the future I see in store.&lt;/p&gt;
&lt;p&gt;Another point is the presentation of the data. Ironically, I think text on a screen is kind of a shit method for this. More so, I think a lot of graphs and charts leave a lot to be desired. I don't want to imply AI and machine learning even more, but I think this is authentically a great application of the tech. If graphs could be analyzed and the data aggregated to produce more fitting visualizations on the fly it would be incredible. Having something that could, for example, take two 2D graphs with a common axis and turn it into one 3d graph would be incredible. In computer science it's well understood fact that any data can be represented graphically in some way, I think finding better ways to dynamically link and graph data would be a huge step in the right direction, paralytically if that data could come from multiple sources. It's amazing how &lt;a href="https://d3js.org/"&gt;many different ways there are of representing the same data too&lt;/a&gt;, and this can help expose otherwise non obvious trends.&lt;/p&gt;
&lt;h2 id="retrieving-and-storing-data"&gt;Retrieving and storing data&lt;/h2&gt;
&lt;p&gt;The theme of this section is going to be decentralization. Because I think this is a subject that has been covered to death, I'm simply going to link to content that I think gets to the point I'm trying to convey&lt;/p&gt;
&lt;p&gt;https://lbry.io/&lt;/p&gt;
&lt;p&gt;https://datproject.org/&lt;/p&gt;
&lt;p&gt;https://ipfs.io/&lt;/p&gt;
&lt;p&gt;One point of contention I have with almost all existing systems is the basis on crypto currency for all storage, I think that public data should be free to store on the network, with encrypted/private data being the only thing that costs money. This has the side effect of promoting using public data, which via hashing can prevent unnecessary storage of duplicated data and the private data can be used to fund the public data overhead costs.&lt;/p&gt;
&lt;p&gt;I think lbry is currently the closest to an implementation that I'm describing, but to my knowledge lbry doesn't host private data. I think builiding upon the ideas of lbry, having data stored as base://user/../folder/../contentname would be best, that way duplicate user names are possible, and then users can chose to either bid for that content name or use base://uuid/samecontentname if they don't want to pay, and then any private content can simply be relegated to the uuid system as well. Sharing data could rather easily be based on unix like file permissions. This idea could also relatively easily be integrated with aforementioned anonomized user profiles/chatting when finding data. Having this user account data be stored on the same decentralized network could also allow for many interesting possibilities.&lt;/p&gt;
&lt;p&gt;I'd also like to mention the idea of distributed computation here as well, as I think it's relevant both for the sake of compression and encryption of the data. I think that having a system like 'this' - I'm referring to all the ideas up until now- in place should ask for contribution from users in turn for it's use, the obvious ask is to get it to be self sufficient. So if the distributed computational power of all these systems were used for everything I've described until now that should be more than plenty to allow it to function. This does bring up the idea of balanced usage to contribution, I think the easiest solution is to simply use a system of computational debt tied to each user account. If the user is creating more computational debt than the average debt the system can sustain then that user should be handicapped in bandwidth accordingly. This does sort of bring us full circle in 'can I just trade debt with someone, or sell them my computational time' though I don't like this ieda for two reasons: 1, this system needs mealtime computation, like electricity peak hours are worth more and 2, this incentives simply paying for compute time instead of actually contributing computational power to the network like it actually needs. Fortunately, as time goes on the amount of computational power should actually get closer and closer to scaling linearly with the amount of content produced as old content is indexed and linked into the network.&lt;/p&gt;
&lt;h2 id="consuming"&gt;Consuming&lt;/h2&gt;
&lt;p&gt;I think it's been pretty well discussed throughout this, but a few extra points about consumption of information include the idea of making strictly ethical design decisions. For example we've all seen biased user interfaces where there's something like this:&lt;/p&gt;
&lt;p&gt;&lt;link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css"&gt;&lt;/p&gt;
&lt;div class="w3-container"&gt;&lt;p&gt;&lt;button class="w3-button w3-red w3-round-xxlarge w3-block"&gt;DO THE THING HERE&lt;/button&gt;&lt;/p&gt;&lt;/div&gt;

&lt;div class="w3-container"&gt;&lt;p&gt;&lt;button class="w3-button w3-black w3-tiny w3-round-xxlarge"&gt;or don't and watch the world burn&lt;/button&gt;&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;where the design is actively pursing an agenda. Instead the affirmative action should be stated on the button that triggers it and both actions given equal weight to the user:&lt;/p&gt;
&lt;div class="w3-bar"&gt;
  &lt;button class="w3-bar-item w3-button w3-red" style="width:50%"&gt;Don't Do Action&lt;/button&gt;
  &lt;button class="w3-bar-item w3-button w3-green" style="width:50%"&gt;Do Action&lt;/button&gt;
&lt;/div&gt;

&lt;p&gt;With destructive or irreversible actions, such as deletion (not recycling), given a confirmation dialogue.&lt;/p&gt;
&lt;p&gt;Beyond that, keeping the design minimal but powerful. I think markdown is a great example of this. User's aren't as dumb as people seem to think, we can, and do, learn the ways to make interaction with the things we use daily faster, so make the 'speed limit' as fast as it can be. Putting a frequently used option into a menu that needs to be clicked at all is much slower than assigning it a keyboard shortcut.&lt;/p&gt;
&lt;p&gt;Furthermore, the design should promote health. An example of this is Netflix's 'Are you still watching?' while this was implemented on their end to prevent unnecessary usage of data, it has the side effect of letting a user know they've been on the couch longer than should probably be advised. I'm not advocating for interruptions at every corner, just affirmative action by the user before bombardment with data. I do think as much data as possible should be linked to or aggregated, but don't show me more than what I request plus some surface level information. For something like YouTube this might mean playing a playlist is fine, but don't start playing another 'related' video when that list is over. For something like an interactive data sheet this would mean showing the most relevant info on the first page, then linking into in one way or another (table of contents, drop down selection menu, etc) into the more detailed information, with the option to remember preferences on displayed info in the future. This actually leads well into my next point:&lt;/p&gt;
&lt;p&gt;Information overload is increasingly becoming a problem globally. As more and more information is accessible at our fingertips and more advertisements have the opportunity to be beamed via any one of a number of surrounding screens directly into our retinas we need a way to filter it down to levels the human brain can cope with and digest.
{{&amp;lt; figure src="{static}/blog/times-square.jpg" caption="Bobby Mikul, Times Square :CC0(https://www.publicdomainpictures.net/en/browse-author.php?a=2185)" &amp;gt;}}&lt;/p&gt;
&lt;p&gt;Worse than the effect of information overload on the brain though is how the way we use technology has trained us to think in the same was as the tools we use. Thinking like I am as I write this, &lt;a href="file:///home/vega/Downloads/challenges-05-00239.pdf"&gt;associating various subjects and grabbing bits and pieces form my life&lt;/a&gt; of experiences is looking to me to be a skill that people don't use as much when using technology. Don't get me wrong, I think as time goes on people are not only getting smarter, but also getting better &lt;a href="https://www.ted.com/talks/james_flynn_why_our_iq_levels_are_higher_than_our_grandparents?language=en"&gt;at this abstract thinking&lt;/a&gt; but I think online, when using technology, these skills are just applied less and we resort back to the linear associations between things. I'm saying this completely anecdotally, partially due to a lack of research. (or at least any that I could find. Then again I'm an engineering major, not a psych major, I may just be missing the right words to ask the question) I think we're just now approaching the stage where instead of merely extending our linear thinking capacity- our memory and computation skills- that computers, as tools extending the mind are starting to be able to extend our abstract and relational thinking as well, so that we can do all the amazing things that come from that type of thought. I fully expect this to be a controversial idea, but I'd love to hear why you think otherwise if you do.&lt;/p&gt;
&lt;h2 id="creating"&gt;Creating&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://medium.com/@whosChrisHughes/creation-vs-consumption-5a13ec020bb2"&gt;Creation&lt;/a&gt; &lt;a href="http://creativecommons.org/publicdomain/zero/1.0/"&gt;vs&lt;/a&gt; &lt;a href="https://georgecouros.ca/blog/archives/tag/creation-versus-consumption"&gt;consumption&lt;/a&gt; &lt;a href="https://magenta.as/the-eternal-struggle-to-balance-creation-and-consumption-3ad26733250b"&gt;is&lt;/a&gt; &lt;a href="https://www.katecrocco.com/blog/nh0rmxidyrv6j7po134zfjazya8ch4"&gt;an&lt;/a&gt; &lt;a href="https://www.thesimpledollar.com/creation-versus-consumption/"&gt;ever&lt;/a&gt; &lt;a href="http://livingexperiment.com/creativity-vs-consumption/"&gt;fought&lt;/a&gt; &lt;a href="https://novemberlearning.com/consumption-vs-creation/"&gt;battle&lt;/a&gt;. How should you spend your time? should it be balanced? should you &lt;a href="https://medium.com/swlh/create-more-than-you-consume-9c1bc89dc71d"&gt;create more than you consume&lt;/a&gt;? Obviously we're hitting hard core life choices and philosophy here. Truth is, I don't care as long as you're (I'm) happy. I love going into YouTube induced comas on a semi-regular basis, but if I didn't also have a creative outlet I think I might explode. Thankfully to me, that creative outlet doesn't need to be something that's classically artistic, but rather anything from programming to making these blog posts works for me. What I will say is for those that chose to create, having the best environment possible, with the best information, tools, and space around them is a huge boon to the output and quality of work. I'm not going to bother finding the evidence because I don't think I need it to support the claim that when we're happier we work better. So, that begs the question, what makes us happy? Look, I'm not about to claim to know the meaning of life here, but I think I can at least point out some relatively obvious things and state what I want in a work environment:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.washingtonpost.com/wp-dyn/content/article/2007/06/04/AR2007060401430.html"&gt;First of all is a low noise floor.&lt;/a&gt; This is sort of an odd one, as different noise matters in different ways dependent on its 'musicality' that is it a repeated pattern, frequency (low is less annoying than moderate, but high is much more annoying than low), etc... For example, right now I'm in a room that has a rather loud computer on part of its fans, giving this room a noise floor of about 50db, making it about the same voulme as &lt;a href="http://chchearing.org/noise/common-environmental-noise-levels/"&gt;a large office&lt;/a&gt; but because that sound is roughly consistently at 120hz, it's an at lest not unplesent background hum. Sadly, on the rare occasion I have that computer off (Let's not talk about how much time I spend in this space) I can actually almost physically feel the change in atmosphere, and is undoubtedly relaxing.&lt;/p&gt;
&lt;p&gt;Next is adequate space for interruptions. While I'm a strong proponent of not eating where you work or consume media as I think it should be an either social or self reflective time, I understand that sometimes it's necessary, and there's nothing worse than not having a flat surface to put your bowl of soup on. More practically though, as mentioned before, it's ideal if the mouse and keyboard aren't in the way of desk space that would otherwise be used for physical craft, note taking, art, etc. So I think three spaces total are ideal: one for primary input devices- today that's a mouse and keyboard -; a second for papers, a main project, etc; and a third that is easily accessible added for the interruptions and side projects in life.&lt;/p&gt;
&lt;p&gt;Next is a visually appealing space. Wires dangling over things, pealing paint, unorganized shelves, etc. are obviously off-putting, but I'd go the step further to say they actively interrupt productivity as they stick out and beg to be fixed. It's the standard scenario of not wanting to do homework until the room is clean. But idealy, I'd go a step further. I think a nice minimal design that accentuates useful things is a good start. Adding a bit of tactile flair can go a long way too. I personally don't want art or static words in my work space as again, they just distract. A bit of sound dampening foam  on the wall your facing can go a long ways both in the visual and sound department, and it's pretty cheap too. Until my dreams of a monitor utopia come, a good start is just getting rid of the base and using a VESA mount to the wall or back of desk. the flexability in position and extra available desk space goes a long ways, and it's much, much more visually appealing. Rather paradoxically, I do see value in motion in the workspace too. For example, &lt;a href="https://www.youtube.com/watch?v=1fV-B0E9rP4"&gt;MIT's reactive table&lt;/a&gt; or those &lt;a href="https://www.youtube.com/watch?v=Ztax9lCE-Mk"&gt;fancy marble in sand tables&lt;/a&gt; can add much needed visual motion to prevent a space from becoming stale. Hell, even a simple fish tank or plant that adds a bit of change with time make's a huge difference.&lt;/p&gt;
&lt;p&gt;To round off the environmental side of creation, and arguably most important is lighting. In recent years redlight shifting/ blue light filtering of screens has come into fassion and for good reason, our eyes and brain are tied together into a biological clock, and it turns out, we can manipulate it pretty well based on how we set our lights. But at the same time the light can be a huge problem too. Without going to in depth white≠white≠white≠white... There's cool and warm and natural white sure, but the 'quality' of this light varies a lot too, there's a lot to be said for getting &lt;a href="https://www.yujiintl.com/high-cri-led-lighting"&gt;high quality lights that put off a natural spread of sunlight emulating frequencies instead of just peaks that make a white&lt;/a&gt;, &lt;a href="https://www.youtube.com/watch?v=DhbMnQt14_o"&gt;this actually makes photography way better too&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Next I'd like to talk about the tools used for creation. This is where I really have a hard time deciding about how money should work because on one end I could just say "Everything you use should be free and open source (FOSS)!" like a hippy, but honestly I don't believe that. What I support instead is free to use personally and open source software that takes a cut of any profit made in return for usage at any sufficiently large corporate scale. This would mean your average joe is free to get their hands dirty with professional software and that in turn means they have experience with and would prefer to continue using the same software for anything commercial. It's a win-win for everyone.&lt;/p&gt;
&lt;p&gt;As far as how all of these tools should work and interact, well, I think they should all use standardized file formats, even if they have to abuse them a little to do so and that they should all have a common Application Programming Interface (API) for interaction. This would hopefully mean that any extension written for one program would work for another, and any program could talk to another. Currently the world of music software has a little bit of this but it still leaves a lot to be desired. I'd actually like to take it a step further though and ask that all data of any kind use a common enough format that it can be processed with any extension/program written with this API in mind. Imagine if you could use a synthesizer as a static generator for image manipulation, or color management controls as an EQ. Both would and should behave in strange way, and it's this very lack of defined behavior that could lead to interesting art forms. I'd love to see a 'Master' Api that works across all formats and ideas with a common data type that allows for program⟺program, program⟺extension, program⟺hardware, etc. communication even in long, complicated chains, in any nodal connection system: (https://github.com/OpenMusicKontrollers)&lt;/p&gt;
&lt;p&gt;&lt;img alt="PatchMatrix" src="https://opinionatedguide.github.io/blog/patchmatrix.png"&gt;&lt;/p&gt;
&lt;p&gt;Potentially this could also plug into the entire OS as well, making it so an image manipulation program's extension could for example modify anything output to the screen in real time, or an audio program could effect the output of anything. For developer's this may even offer more power, making possible things such as interprocess communication (think pipes, like $ls -la | grep *.png) a matter of connecting two nodes, or reading disk information such as activity, space, or even writeback and inode information, this would literally allow any one piece of information to be accessible to any other. This does have obvious permission issues, but unix permissions should already have this under control. If something like this could also be tied into the originally mentioned web searching and socialization web without massive security concerns the potential use cases are as simple as getting color information from an image hosted online to as complicated as remote access or distributed computing.&lt;/p&gt;
&lt;p&gt;&lt;img alt="PsCircle" src="https://opinionatedguide.github.io/blog/pscircle.png"&gt;&lt;/p&gt;
&lt;p&gt;or even supporting a full programming environment sort of like &lt;a href="https://www.luna-lang.org/"&gt;Luna&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Luna" src="https://opinionatedguide.github.io/blog/luna.png"&gt;&lt;/p&gt;
&lt;h2 id="wrapping-up"&gt;Wrapping up&lt;/h2&gt;
&lt;p&gt;In all honestly I'm not exactly sure what everything I just wrote is about. Mostly it's just a brain dump, but hopefully it's an interesting one. To round things off with a bit of a closing note though, I don't actually foresee many of these things being possible, if not simply because they're require so many people to agree on &lt;a href="https://xkcd.com/927/"&gt;standards&lt;/a&gt;, but there is one glimmer of hope, and it's one of proof of uniformity. The terminal. Yes. This terminal:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Terminal" src="https://opinionatedguide.github.io/blog/termex.png"&gt;&lt;/p&gt;
&lt;p&gt;The terminal emulator above is still compatible with the VT220 from 1983 (as are most terminal emulators) yet from it I can do everything I can really think of: &lt;a href="https://askubuntu.com/questions/29540/browsing-the-internet-from-the-command-line"&gt;browse the web&lt;/a&gt;, &lt;a href="https://www.omgubuntu.co.uk/2016/10/use-telegram-cli-in-terminal-ubuntu"&gt;chat with friends&lt;/a&gt;, &lt;a href="https://github.com/PromyLOPh/pianobar"&gt;listen&lt;/a&gt; to &lt;a href="https://wiki.archlinux.org/index.php/ncmpcpp"&gt;music&lt;/a&gt;, &lt;a href="http://www.tuxarena.com/2014/03/20-great-terminal-replacements-for-gui-applications/"&gt;basically anything&lt;/a&gt;. I'm not saying we should all stop using chrome (&lt;a href="http://www.tuxarena.com/2014/03/20-great-terminal-replacements-for-gui-applications/"&gt;You totally should though&lt;/a&gt;) but I think part of the reason so many neck beards and sys admins still use the terminal is you can do so much with it, and because everything uses it as a common interface and it has programming capabilities (or at least bash/zsh/whatever does) you can automate or string together just about anything, exactly as I described above. In fact, I think it would be amazing if all the graphical 3D node based exploration and data flow editing I described above had underlying syntax that could be written directly for the nitty gritty when desired, sort of like aforementioned &lt;a href="https://www.luna-lang.org/"&gt;Luna&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally, I'd like to say I understand we don't all get the choice, be it by monetary, physical, or other restrictions to have a 'perfect' work environment. If you live in the city, there will be noise, I get that. Obviously I don't expect everyone to go out and make their own versions of some of the high tech borderline art installations I linked either. I also don't think everyone's down to get an RFID tag in their hand. I just wanted to present what I see as 'the future' weather it comes in 2018 or 20018. I do, however, hope this has inspired you to look at the way you work, the environment you work in, and how you can improve it. Weather it be by &lt;a href="https://www.datamation.com/open-source/78-open-source-replacements-for-expensive-applications-1.html"&gt;switching software&lt;/a&gt;, &lt;a href="https://www.instructables.com/id/Zip-Tie-Cable-Management/"&gt;tidying up those cables&lt;/a&gt;, or &lt;a href="https://imgur.com/gallery/uYeV6G9"&gt;making a bad&lt;/a&gt; &lt;a href="https://imgur.com/a/7FGxi"&gt;ass desk&lt;/a&gt;, I hope something comes of this post.&lt;/p&gt;
&lt;h3 id="other-interesting-and-sort-of-related-things-that-didnt-seem-to-fit-anywhere-nicely"&gt;Other interesting and sort of related things that didn't seem to fit anywhere nicely&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.youtube.com/watch?v=Mgy1S8qymx0"&gt;ReacTable&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Netsukuku"&gt;Netsukuku&lt;/a&gt; (&lt;a href="https://github.com/Netsukuku/netsukuku"&gt;2&lt;/a&gt;),&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Written the next day,&lt;/p&gt;
&lt;p&gt;Yesterday I posed an accidental novella that, while a bit of a mess, made some interesting recommendations for how we change the way we interact with computers. In this post I'd like to actually look at a vision of implementation of these ideas.&lt;/p&gt;
&lt;p&gt;One of the heaviest underlying theme's of Part 1 was this idea of a nodal browser and editor. This is where I'm going to be spending about 98% of this post: digging into a potential implementation of this idea.&lt;/p&gt;
&lt;p&gt;To begin with, my idea faces a crippling problem: mixed data sources and types. How on a graph could users profiles, web pages, system devices, local files, and data manipulation nodes all coexist? The answer, to me, is they don't have to, at least not all at once. I think the easiest implementation isn't of a 3 dimensional graph, but rather an 2+1 dimensional graph, by this I mean giving a control which selects what's held in the main plane (in the YZ, x=0), and then a choice of a third node source that exists in planes behind this (YZ plane, X&amp;lt;0). The reason I've defined them that way is because I think it makes more sense to navigate in a screen by 'flying' to or away from something than it does to let the vertical axis define the 3rd relation. (This assumes a graph where X is the axis perpendicular to the screen, Z is the axis running parallel to the vertical edge, and Y the axis parallel to the horizontal edge)&lt;/p&gt;
&lt;p&gt;Alright, so, that's a bit of a start but still very hard to visualize. What this might mean is that all file-type data- webpages and local files- are represented as a graph only on the YZ, while functions on this data are held in the same plane, but behind this data. Say theres content on example.com that you want to store into a file on your local system: a link could be taken from the site and fed into a functional node that exists in a plane behind this main file navigation one, then a link created from this function into a new file node that's in a branch:&lt;/p&gt;
&lt;p&gt;Though by defining dimensions to be able to hold whatever you like this could be incredibly flexible. For example, instead of storing a third data type in a constant plane behind the main one, the depth into the X direction could be set as a log() of the time since file modification, showing the relative age of data visually. Even more interesting though, the relationship in the primary plane wouldn't have to be strict. Up until now I've been implying a file tree like stricture of the data; so files in folders, web pages following the navigation of the site, etc; However, this could instead be based on attributes of the data at hand, sorting audio files all together. For example this could show links between any audio files, which are then clustered by genre, and then even more tightly clustered by artist, with a now surrounding outlined region linking the encompassed nodes to the artist. This, existing in a visually outlined region of the genre and so on. Bringing this back to the concept of having functions in a further back plane, these functions could act on linked sets of data now, allowing for easy processing of data based on various selected attributes.&lt;/p&gt;
&lt;p&gt;Say you wanted to apply an EQ profile to any song by X artist that is also instrumental, these two criteria could be filtered for and then linked into that processing function.&lt;/p&gt;
&lt;p&gt;All of this would allow for graphs that can vary in complexity and representation based on what is most useful to the user.&lt;/p&gt;
&lt;p&gt;To be extra clear though this primary front-most plane wouldn't have to contain files or web pages, it could be aforementioned programs in the front with data types in the back, or system devices on the main plane (keyboard, mouse, gpu, cpu, mem, usb devices, disks...) with user profiles 'behind' this. I'm not sure &lt;em&gt;why&lt;/em&gt; you would do that but the point is that you should be able to. Finally, from the navigation of data side is the idea of letting nodes contain graphs in themselves, Luna and Audulus both have this concept implemented pretty well. It can do a pretty good job of abstracting more complicated structures were desired. To make this clear I mean nodes could contain smaller networks of nodes when 'entered' as a way of reducing outward compelxity when only a higher level view is desired. Ie, if all you care is a car drives that's fine, but inside a 'car' data structure you may find nodes storing data with inputs and outputs for things like an engine, transmission, etc. in the engine node you may see inputs and outputs and data storage for things like pistons firing.This makes it so layers of abstraction can literally be represented visually the same way functions can encompass complex behavior when programming. Again, this is not an original idea. Basically any flow based programming language has some aspect of this.&lt;/p&gt;
&lt;p&gt;Moving on to how individual nodes would be 'defined' they should have a textual and visual representation, sort of like in Luna. This allows for a scalpel to be taken to the things that require it without 'diving into' nodes to the point of confusion where you get n layers of nodes deep in something like the above mentioned car example. Each node, as well as literally every file, program, and data source/sink on the system should be defined with some sort of common data wrapper which is used to generate the nodes structure, I'm imagining something like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;Inputs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;Outputs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;metadata&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;span class="nl"&gt;data&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Where a specific example, a .wav may have a wrapper that looks something like this&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;Inputs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;null&lt;/span&gt;
&lt;span class="nl"&gt;Outputs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nl"&gt;AudioData&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nl"&gt;ChannelL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nl"&gt;Frequency&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frequency&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;
            &lt;span class="nl"&gt;Amplitude&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;amplitude&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;
        &lt;span class="nl"&gt;ChannelR&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="nl"&gt;Frequency&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frequency&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;
            &lt;span class="nl"&gt;Amplitude&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;amplitude&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;
&lt;span class="nl"&gt;metadata&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nl"&gt;NodeType&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Audio&amp;quot;&lt;/span&gt;
    &lt;span class="nl"&gt;Album&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Only Solutions&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Journey&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Separate Ways (Worlds Apart)&amp;quot;&lt;/span&gt;
    &lt;span class="nl"&gt;Title&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Separate Ways&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;World&amp;#39;s Apart&amp;quot;&lt;/span&gt;
    &lt;span class="nl"&gt;Artist&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Jounery of Zepplin&amp;quot;&lt;/span&gt;
    &lt;span class="nl"&gt;Lyrics&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;
    &lt;span class="nl"&gt;Tags&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Rock&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;80&amp;#39;s&amp;quot;&lt;/span&gt;
    &lt;span class="c1"&gt;//Begin format dpndt wrapper&lt;/span&gt;
    &lt;span class="nl"&gt;extension&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;.wav&amp;quot;&lt;/span&gt;
    &lt;span class="nl"&gt;format&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;
    &lt;span class="nl"&gt;samplingfrq&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;48000&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;


&lt;span class="nl"&gt;data&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="mh"&gt;0x0000130&lt;/span&gt; &lt;span class="mh"&gt;0x0101010101010101c0ff11000108012c&lt;/span&gt;
    &lt;span class="mh"&gt;0x0000140&lt;/span&gt; &lt;span class="mh"&gt;0x032c2201020001111103ff0100c4001f&lt;/span&gt;
    &lt;span class="mh"&gt;0x0000150&lt;/span&gt; &lt;span class="mh"&gt;0x01000105010101010001000000000000&lt;/span&gt;
    &lt;span class="mh"&gt;0x0000160&lt;/span&gt; &lt;span class="mh"&gt;0x010003020504070609080b0ac4ffb500&lt;/span&gt;
    &lt;span class="mh"&gt;0x0000170&lt;/span&gt; &lt;span class="mh"&gt;0x00100102030304020503040500040100&lt;/span&gt;
    &lt;span class="mh"&gt;0x0000180&lt;/span&gt; &lt;span class="mh"&gt;0x017d0302040005112112413113066151&lt;/span&gt;
    &lt;span class="mh"&gt;0x0000190&lt;/span&gt; &lt;span class="mh"&gt;0x220714718132a1912308b14215c1d152&lt;/span&gt;
    &lt;span class="mh"&gt;0x00001a0&lt;/span&gt; &lt;span class="mh"&gt;0x24f0623382720a0917161918251a2726&lt;/span&gt;
    &lt;span class="mh"&gt;0x00001b0&lt;/span&gt; &lt;span class="mh"&gt;0x2928342a363538373a39444346454847&lt;/span&gt;
    &lt;span class="mh"&gt;0x00001c0&lt;/span&gt; &lt;span class="mh"&gt;0x4a495453565558575a59646366656867&lt;/span&gt;
    &lt;span class="mh"&gt;0x00001d0&lt;/span&gt; &lt;span class="mh"&gt;0x6a697473767578777a79848386858887&lt;/span&gt;
    &lt;span class="mh"&gt;0x00001e0&lt;/span&gt; &lt;span class="mh"&gt;0x8a899392959497969998a29aa4a3a6a5&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;This would initially define one node with an output of type 'AudioData' worth noting, this doesn't actually handle decode, that would be left to another type of node, one that contains a music player most likely. Also, this node would only appear to have one output, but another type of node could be defined like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;Inputs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//lamda represent a fuction to be exectued to inorder to build the node, where as something without the lamda is actually a visually represented i/o on the nod&lt;/span&gt;
    &lt;span class="err"&gt;λ&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getinput&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="c1"&gt;//declaring an input that can become any type should be possible. I&amp;#39;m not saying this void syntax is good, but this also purly a hypothetical idea at this point.&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;
    &lt;span class="c1"&gt;//also note the lack of a funcitonal lamda means this would be an attachable input&lt;/span&gt;
&lt;span class="nl"&gt;Outputs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//outputs can use vars declared input, I can&amp;#39;t think of a situation that would need to be the other way around.&lt;/span&gt;
    &lt;span class="err"&gt;λ&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getoutputs&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;totree&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;traverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="c1"&gt;//note the lack of a funcitonal lamda means this would be an attachable input too,&lt;/span&gt;
    &lt;span class="c1"&gt;//though it&amp;#39;s varible in size and complexity based on the second level of the output definiton of the input node&lt;/span&gt;
&lt;span class="nl"&gt;metadata&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nl"&gt;NodeName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;NodeType&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Data Splitter&amp;quot;&lt;/span&gt;
&lt;span class="nl"&gt;data&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So that the data output of each channel could be interacted with directly, say to be piped though an EQ or filter first.&lt;/p&gt;
&lt;p&gt;Also, this is actually generic, so it could be used to access the second level of any input, though if someone wanted theres also no reason the header of the wrapper for the wav file couldn't be modified to just remove the original audio data grouping in the first place; however, it would probably need to be regrouped before getting to a decode application. Or the outputs could be defined fictionally meaning the node could be entered and this could just be remapped inside the node visually. Or, even weirder yet this system would let you define your file as separate data structures all together, with one node that functionally one gets it's data from the left channel and another that only got the data from the right. Obviously the options here are infinite but different solutions and approaches are probably better than others, thought that choice is left to the user/developer.  &lt;/p&gt;
&lt;p&gt;One more example just to get this idea defined:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;Inputs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="err"&gt;λ&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hidraw0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;input&lt;/span&gt;
&lt;span class="nl"&gt;Outputs&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="err"&gt;λ&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;keymap&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;output&lt;/span&gt;
&lt;span class="nl"&gt;metadata&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nl"&gt;NodeName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;HID Device&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getvendorid&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="nl"&gt;data&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nl"&gt;keymap&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="c1"&gt;//dvorak key map&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;~&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;~&amp;quot;&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="sc"&gt;&amp;#39;q&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;#39;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="sc"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;/&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="sc"&gt;&amp;#39;z&amp;#39;&lt;/span&gt;        
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Which would be one way of setting up a keyboard and assigining it a Dvorak layout, now, ironically this example probably isn't the best, since that map would make more sense if it were defined as it's own node. Though, to some extent, due to the lamda, it would be since that would make the map fiction be an internal function if you were to 'enter' the node.&lt;/p&gt;
&lt;p&gt;This wrapper could extend to literally everything in the system from image files where you have resolution, (R, G, B) @ pos, etc., to the generic wrapper for programs- exposing the virtual memory mapping and data, cpu usage, running status, etc., For example, a node for a text editor process may, when displayed on the 3D view with the system nodes, expose the connection to the input devices, the output of the window to the frame buffer... you get the idea. Also this brings up the idea of contextual i/o&lt;/p&gt;
&lt;p&gt;Part of the beauty behind this is there's no reason any data type couldn't be mapped to another. This would mean something meant to control the color profile of a picture may be able to be repourposed into an EQ for music, or a synthesizer used as a source for noise generation in photo editing.   &lt;/p&gt;
&lt;p&gt;Because I/O can be seen visually by the user, if something like a virus wanted to 'phone home' it would at least temporarily be forced to make a visual connection on screen. Speaking of, connection and node color can carry a lot of visual information for the user. For example an node outputting audio could change in color based on frequency and in saturation based on amplitude. The process doing this could be just be internally connected (not shown unless the node is 'entered') node in of itself.&lt;/p&gt;
&lt;p&gt;One of the bigger ideas this network could implement is machine learning and tag based recognition of data to make connections between nodes and their internal data even easier to find. To avoid repeating myself to much, just checkout the &lt;strong&gt;Finding Information&lt;/strong&gt; section of the last post. Furthermore, the methods for distributing the computational workload imposed by this as well as how I think it should be stored are covered to a reasonable extent in the &lt;strong&gt;Retrieving and storing data&lt;/strong&gt; section. (&lt;a href="http://deftwing.us/Human%20Computer%20Interfaces.html"&gt;link to parent post&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Finally, I think it's worth mentioning to what extent I think this could be made a reality, or at the very least a decent proof of concept. Linux, by nature of the '&lt;a href="https://en.wikipedia.org/wiki/Everything_is_a_file"&gt;everything is a file&lt;/a&gt;' concept, should allow for this, though this even has it's limits I do think it would allow for the vast majority of this functionality given enough work/effort. From a display and rendering perspective I think the Arcan display server is well suited to this concept and makes it a far less ambitious (though far less ambitions than needing to make a new display server and/or OS isn't exactly lowering the bar much). It's also worth noting that as I described in the parent post to this, the old school Linux terminal is in a way a proof of concept to this, as it already supports data flow programming in the form of &lt;a href="https://www.tldp.org/LDP/abs/html/io-redirection.html"&gt;i/o redirection&lt;/a&gt;, (&lt;a href="https://ryanstutorials.net/linuxtutorial/piping.php"&gt;2&lt;/a&gt;) like pipes.&lt;/p&gt;
&lt;h3 id="relevant-links"&gt;Relevant Links:&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.unrealengine.com/en-us/Engine/Blueprints"&gt;Unreal Engine Blueprints&lt;/a&gt;, &lt;a href="https://www.luna-lang.org/#Overview"&gt;Luna&lt;/a&gt;, &lt;a href="https://puredata.info/"&gt;PureData&lt;/a&gt;, &lt;a href="http://www.vsxu.com/"&gt;VSXu&lt;/a&gt;, &lt;a href="https://github.com/tuxarch/pscircle"&gt;PSCircle&lt;/a&gt;, &lt;a href="http://xcruiser.sourceforge.net/"&gt;Xcruiser&lt;/a&gt;, &lt;a href="https://vvvv.org/"&gt;vvvv&lt;/a&gt;, &lt;a href="http://www.joshknows.com/grc#screenshots"&gt;GNU Radio Comanion&lt;/a&gt;, &lt;a href="https://www.caida.org/tools/visualization/walrus/"&gt;Walrus&lt;/a&gt;, &lt;a href="https://github.com/letoram/arcan"&gt;Arcan&lt;/a&gt;, &lt;a href="https://github.com/letoram/arcan"&gt;Durden&lt;/a&gt;, &lt;a href="https://github.com/letoram/senseye/wiki"&gt;Senseye&lt;/a&gt;, &lt;a href="https://en.wikipedia.org/wiki/Netsukuku"&gt;Netsukuku&lt;/a&gt; (&lt;a href="https://github.com/Netsukuku/netsukuku"&gt;2&lt;/a&gt;), &lt;a href="https://github.com/OpenMusicKontrollers/patchmatrix"&gt;Patchmarix&lt;/a&gt;, &lt;a href="https://lbry.io"&gt;Lbry&lt;/a&gt;, &lt;a href="https://datproject.org"&gt;Dat&lt;/a&gt;, &lt;a href="https://ipfs.io"&gt;IPFS&lt;/a&gt;, &lt;a href="http://wiki.polyfra.me/"&gt;3DWikipedia,&lt;/a&gt; (&lt;a href="http://www.wikiverse.io/"&gt;2&lt;/a&gt;),&lt;/p&gt;</content><category term="Blog"></category><category term="Engineering"></category><category term="Blog"></category></entry><entry><title>Vega's Setup and Workflow</title><link href="https://opinionatedguide.github.io/Vega's%20Setup%20and%20Workflow.html" rel="alternate"></link><published>2019-07-29T13:33:29-05:00</published><updated>2019-10-14T12:02:23-05:00</updated><author><name>Vega Deftwing</name></author><id>tag:opinionatedguide.github.io,2019-07-29:/Vega's Setup and Workflow.html</id><summary type="html">&lt;p&gt;I've always had a strange interest in optimization. This is probably one of the reasons I love working with computers and electronics so much- they can be used to optimize, sometimes to the point of automation, so many tasks and then even the execution of this task itself can be …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I've always had a strange interest in optimization. This is probably one of the reasons I love working with computers and electronics so much- they can be used to optimize, sometimes to the point of automation, so many tasks and then even the execution of this task itself can be made faster and better by writing better and better code. But I don't just see opportunity for optimization in programming, but also in how we go about our day to day lives. Thus, I tend to spend more time than is probably optimal optimizing my own workspace and work flow. So here goes: This is how I work.&lt;/p&gt;
&lt;h1 id="my-digital-home"&gt;My Digital Home&lt;/h1&gt;
&lt;p&gt;I mostly use Linux because I find the way in which Windows forces work flow patterns onto the user incredibly annoying. I prefer to setup my system in a way that works for me. Using Linux doesn't really tell you much though, as theres a lot of options here. So, to start with, this is a screenshot of one of my screens:&lt;/p&gt;
&lt;p&gt;&lt;img alt="test" src="https://opinionatedguide.github.io/blog/cleanscrot.png"&gt;&lt;/p&gt;
&lt;p&gt;In Arch Linux I use i3, polybar, and rofi for my desktop enviroment. At the bottom of this screen shot is 'Polybar', a customizable bar that can take input from any command line program and display it on the bar, and has some capability for interaction, like playing or pausing my music. I have mine setup a bit different on each screen, but worth noting is the centered text in the bottom which is Tolkien's Tengwar (elvish), these are the names of my open workspaces in the i3 window manager, my preferred desktop environment as it maximizes the use of screen real estate and allows for very fast movement of windows or workspaces among monitors- something I find tedious on windows or on in floating window window managers - as it is a tiling window manager. If you're not sure what that is, I recommend you give it a Google. (or DuckDuckGo, or whatever you prefer. You do you.) But this picture may be enough to give you the idea:&lt;/p&gt;
&lt;p&gt;In the middle of the screen is Rofi, which I use for launching programs (&lt;a href="https://github.com/cspeterson/splatmoji"&gt;and inserting emoji/kaomoji&lt;/a&gt;). Rofi more than fits my needs as it &lt;em&gt;just works&lt;/em&gt;, and does so quickly.&lt;/p&gt;
&lt;p&gt;For file management I use a combination of Thunar and cli tools. I use Thunar for a graphical file manager when I want to move a lot of files around because of it's fast navigation by typing the beginning of a word. I'm still not 100% happy with it, as a fuzzy search of what I'm typing would be nicer, but overall it works pretty well.&lt;/p&gt;
&lt;p&gt;When chilling in a terminal I know I &lt;em&gt;should&lt;/em&gt; use something like ranger, a popular cli file browser, but more often than not I use the basic built in tools of cp, mv, etc. in combination with autojump. Like most things in life &lt;a href="https://en.wikipedia.org/wiki/Zipf's_law"&gt;Zipf's Law&lt;/a&gt;, applies so really the vast majority of the folders I visit are very quickly navigated with autojump.
Furthermore, I personally find that quite often I know some thing other than the name of a file that I need to find, so using &lt;code&gt;ncdu&lt;/code&gt;, a terminal based disk usage analzer that can look at any folder recursively, is easy when I know I'm looking for a large file. ripgred and fd fill the gaps for when I know something about what's in the file I'm looking for. Finally, I end up using rsync fairly regularly because I own way to many hard drives and ssds.&lt;/p&gt;
&lt;p&gt;In that screenshot you'll also see I use two different terminal emulators. 'Deepin-Terminal' is my main go to, where I run ZSH day to day with OhMyZsh and the gnzh theme. Deepin-Terminal is quite good looking and has nice feature and easy themeing. As a secondary terminal I use Hyper with &lt;a href="https://xon.sh/index.html"&gt;xonsh&lt;/a&gt;, a great shell that can run both python and bash in the same terminal and allows for mixing the two languages. It's great for quick and dirty one time use scripts.&lt;/p&gt;
&lt;p&gt;On the note of the shells, my .zshrc, .xonshrc, and other config are available for download at &lt;a href="https://github.com/VegaDeftwing/confs"&gt;this github link&lt;/a&gt; But I'd like to go in depth a little here.&lt;/p&gt;
&lt;p&gt;I've 'replaced' via alias some of the built in commands like cat with alternatives like bat so that they work better for my needs. You'll also notice a few single letter aliases. The most frequently used of those are h to open htop and n for ncmpcpp, my music player (well client) of choice. I find out of the seemingly infinite number of music players I've tried ncmpcpp is the fastest and easiest to use once it and mpd are configured, and it doesn't crash when loading my massive library. I also use TaskWarrior for managing todos.&lt;/p&gt;
&lt;p&gt;Getting out of my shell, some of the graphical programs I use everyday include Vivaldi as my web browser and typora or marktext for text editing in markdown. Vivaldi was a no brainier once firefox killed off Tree-Style-Tab and I couldn't bring myself to go back to tabs at the top. Since I've switched Firefox has made Tree Style Tabs possible again; however, I find that Vivaldi is just a hair faster for my needs. Typora and Marktext (I usually use marktext, but typora has TOC support which I need for large docs) are my go to for just spewing out text, like this, since they're unobtrusive and just let the content flow without formatting getting in the way. I've also found that they work wonders for taking notes in classes.&lt;/p&gt;
&lt;p&gt;To quickly rattle off some others, I typically do most of my chatting through telegram which has a fantastic Linux client, though occasionally use IRC through IRSSI. I use Whalebird to post on Mastodon when I'm in the tooting mood. I do some package management using Pamac as I'm running Arch Linux, but do prefer to use &lt;code&gt;yay&lt;/code&gt; in the terminal as it takes care of my packages in the AUR as well. For my officey things I have yet to find a scenario where libreoffice doesn't do what I need. I mostly use nomacs for quickly viewing or doing minor edits to images. My main editor for hammering out code is VsCode with the PlatformIO IDE extensions as well as a bunch of extra plugins (Colorized brackets are a must). Also I have steam and Itch.io installed for gaming, though sometimes I reboot into Windows anyway, mostly for VR stuff though as with Proton most things run well enough anyway. For video editing, sadly, linux just hasn't quite had an offering I'm happy with yet so I reboot to windows to use Davinci Resolve (yes, I know Resolve can run in Linux, but it sucks). When drawing digitally I use a 1080pen tablet with Krtia to hammer out the base image unless I want to do something weird, in which case I might use any of a number of strange art tools including (but not limited to) Hexels, Black Ink, ColorTool, Dotgrid, Ronin, MagicaVoxel, and RexPaint.&lt;/p&gt;
&lt;p&gt;I also end up spending a fair amount of time making music, and frequently get lost playing music in &lt;a href="vcvrack.com/"&gt;VCV Rack&lt;/a&gt;, where I use Cadence and Catia for running the Jack server and routing audio. I also sometimes use &lt;a href="vcvrack.com/"&gt;ORCΛ&lt;/a&gt;, a cool creative coding midi/osc tool for sequencing things. Rarely I use Renoise as well, when I'm in the mood for tracker based music production.
Though, as much as I hate it, I often boot back to Windows so I can make music using Ableton Live and a whole pile of VSTs along with VCV and my real eurorack hardware. I also typically run field recordings and samples through audacity as a quick once over to fix the audio up a bit.&lt;/p&gt;
&lt;p&gt;For electronics I use KiCad and Circuit Simulator mostly, though I've used Simulide on occasion. I also have Vivado and STMCube installed for when I absolutely have to use them.&lt;/p&gt;
&lt;p&gt;I super rarely use some other misc tools like Blender 2.8, Etherape, Cutter, but not enough to go into much detail.&lt;/p&gt;
&lt;p&gt;from a direct workflow perspective it obviously depends on what I'm doing. As covered previously for large, basic text documents I prefer markdown and those editors. Office is Libreoffice etc. But as I use those I like to have one monitor running a task that I deem a background task - something nearly autonomous that needs intervention once every hour at max, one monitor for web and other media browsing/research, and one monitor for the actual task at hand. In the case of less screens I settle for organization via workspace. I tend to use Git a lot and try to plan and document just as much as I 'actually work'.&lt;/p&gt;
&lt;p&gt;To manage my schedule I have given in to the privacy sacrifice and use Google Calendar and the Sectograph app on both my phone and smart watch (both android).&lt;/p&gt;
&lt;h1 id="in-the-real-world"&gt;In the Real World&lt;/h1&gt;
&lt;p&gt;&lt;img alt="desksetup" src="https://opinionatedguide.github.io/blog/desksetup.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Starting with how I interact with my computer, I'm one one of the nerds that uses Dvorak, but I've actually gone further than that as I have an Ergodone that a friend built for me and I've made my own layout which allows me to type some extra fun characters that come in handy: ☐☑☒⎨⎪⎫...ⅰⅱⅲⅳäő≥≤ ... you get the idea. If you have a QMK board as well the code has been pushed to the QMK repo and is availabe &lt;a href="https://github.com/qmk/qmk_firmware/tree/master/keyboards/ergodone/keymaps/vega"&gt;here&lt;/a&gt;. I also have a Stinky Footboard, which is literally a keyboard for your feet, that I've replaced the controller in so that it runs QMK as well, and I use it to for media control (play, pause, next, prev, shuffle). My mouse is a Roccat tyon, and I've found it pairs really well with i3 and multiple monitors so I can navigate around my large screen realestate quickly simply by flicking my fingers.&lt;/p&gt;
&lt;p&gt;I don't want to go into spectacular detail about my specific hardware though, partially because I don't see any value in hardware bragging, partially because it's not applicable knowledge to most people. I will share that I think mechanical keyboards are bomb, and I love my Box White switches but CherryMX Blue keys are great too. I tend to prefer rocking a large, bulky tower so I can do frequent hardware swaps, and I usually have an obscene amount of USB devices attached to my system (at one point I had over 35). I've found for me, that 3, 27", 16x9 monitors in a row is a sweet spot, but obviously cost and space are considerations, on top of that I have a 1080p pen tablet, but honestly it's almost to much screen for one person to manage, so I leave that off most of the time. Running 4k can have it's downsides though, so having a quick to access 1080p screen when necessary is nice. Back to a workflow perspective, when I can I like to have a large, deep desk with a slide out keyboard tray so I can work on papers or other projects directly on my desk and get my keyboard and mouse out of the way when I want. I also like to use speakers rather than headphones when I can without bothering people as I find the comfort and freedom to move around much nicer. Right now I'm running a quadraphonic setup as well, which is a total blast when making music.&lt;/p&gt;
&lt;p&gt;When I'm on the go I vary between two laptops, one that is a royal piece of junk that has a similar to my normal linux set up on it, and one that's running Win10 and a clone of my normal Arch setup on my desktop. The nicer laptop is a pretty beefy system for it's weight with some of the most bottle necked specs I've ever seen. The i7-xxxxU part is still funny to me. How intel can call a system with 2 cores an i7 in 2017 (when this laptop was released) is beyond me, but I digress. It works rather well for just taking notes and getting stuff done in classes, and I have windows on it as it ensure compatibility in the more professional environments. Furthermore, I can always just SSH into the my home desktop- since I have a backup ssh key stored in the RFID implant in my right hand that's never an issue either.&lt;/p&gt;
&lt;p&gt;Other than that I have some hardware I use when working with electronics like a RigolDS1054Z Oscilloscope which is absolutely overkill for most of what I do and has served me well as well as a LHT00SU1 logic analyzer that I can use with PulseView on linux. I keep the majority of my smaller componentry (ceramic and electrolytic caps, transistors, resistors, diodes) in a binder filled with baseball card holders that have been labeled with sharpie. This is by far the most space effient method I've found for organization assuming you can trust yourself not to accidentally turn the binder upside down. I also have a tackle box filled with boxes of ICs, a small set of generic slide out drawers with bulk misc components, and a small toolbox for bulk connectors and wires. My actual tools themselves are mostly strewn about as they get used so often, but my main go to tools are a set of IFixIt screwdivers, wire snips, a bendy 6-armed 3rd hand for holding what I'm working on, and a cheap but functional multimeter - the AstroAI WH5000A.&lt;/p&gt;
&lt;p&gt;On my desk I use the 49key Launchkey Mk2, LaunchPad MK2, and Artuira Beatstep Midi controllers, along with a Leap Motion running Geco (it's a lot like a theramin for MIDI input) when I want live input when making music. When not in use most of the gear nicely slides underneath my monitors.&lt;/p&gt;
&lt;p&gt;On the note of music, I have a pile of guitars - 2, 6 string electrics; a 12 string acoustic with a pickup tossed in; and a 6 string acoustic with two different pickups mounted internally. One of the electrics has a whammy bar while the other has an gyro hidden inside with a USB cable coming out so I can send midi information based on orientation. I often use a pitch-&amp;gt;CV module in VCVRack as an input over the 49 key keyboard as I find pitch tracking on a guitar much more expressive. At some point I need to splurge for an actual midi pickup.
I also have a decent starter Eurorack setup for making modular synth noises and music which I've been using for developing my own modules as well. As of now the setup consists of the Behringer Neutron, a few mults, a Zone BF dual LFO, an 'Event' Function/ADSR/OSC, a dual VCA, a uO_C running Hemispheres, a Mod Demix ring modulator, and Tempi as a clock source.&lt;/p&gt;
&lt;h1 id="the-typical-day-of-a-vega"&gt;The Typical Day of a Vega&lt;/h1&gt;
&lt;p&gt;I usually wake up at about 7:30, and then actually get my ass out of bed by around 8:00 and then be fully up and running- having had breakfast if I chose to- by 9:00&lt;/p&gt;
&lt;p&gt;From 9 to 10:30ish on most days I'll fire up some Youtube and get a dose of news and content that's usually more educational in nature and usually tech related. My main go tos are &lt;a href="https://www.youtube.com/channel/UC4w1YQAJMWOz4qtxinq55LQ"&gt;Level1Techs&lt;/a&gt; and &lt;a href="https://www.youtube.com/user/sxephil"&gt;Philip DeFranco&lt;/a&gt; for news, and then content like that from TED talks, DefCon panels, &lt;a href="https://www.youtube.com/user/TheChemlife/videos"&gt;The Theught Emporium&lt;/a&gt;, &lt;a href="https://www.youtube.com/user/theCodyReeder"&gt;Cody's Lab&lt;/a&gt;, &lt;a href="https://www.youtube.com/channel/UClcE-kVhqyiHCcjYwcpfj9w"&gt;Live Overflow&lt;/a&gt;, &lt;a href="https://www.youtube.com/channel/UCG7yIWtVwcENg_ZS-nahg5g"&gt;CNLohr&lt;/a&gt;, &lt;a href="https://www.youtube.com/channel/UCYO_jab_esuFRV4b17AJtAw"&gt;3Blue1Brown&lt;/a&gt;, and &lt;a href="https://www.youtube.com/user/thisexists"&gt;This Exists&lt;/a&gt; to name some of my favorites. at around 10:30 I take about 10 minutes to go through my schedule for the rest of the day and make sure my schedule and mandatory todos/deadlines match up and make any corrections that are necessary. Then I try to hammer out at least a little work on something that's on that list by either priority or just what I'm actually feeling up for. Around this time is where I usually have class, though that schedule varies from day to day, (or if it's summer) with most days I'm done between 3 and 5, from there It's a good mix of planned out time for myself, projects, and work/school. I do try to micro manage my schedule as a tentative plan (at least for weekdays) but I rarely end up actually sticking to that schedule. It's more of an extra reminder that I should be spending about that much time that day on that thing. I'm actually working to following it more rigidly though as it does have time set aside for all of the things I generally want to do and prevents me from accidentally getting into a YouTube induced coma.&lt;/p&gt;
&lt;p&gt;To Further prevent time wastage I have my watch set to do very short vibrations, one pulse at the half hour, and two short pulses at the hour ( &lt;a href="https://theamphour.com/397-5-an-interview-with-loial-from-krontech/"&gt;This wasn't actually my idea though&lt;/a&gt; ). This works pretty well actually, and has the added benefit of over time (pun intended) helping to develop a better 'feel' for what time it is.&lt;/p&gt;
&lt;h1 id="writing"&gt;Writing&lt;/h1&gt;
&lt;p&gt;When writing I usually stick with a simple outline first, fill in what I know, then mark todos for the gaps to come back to. This applies both for technical writing or documentation and for fictional story writing. I find this has the annoying side effect of expanding scope pretty bad, but it also ensures that everything that needs talked about is talked about. Of course the outline grows with the paper as well, but oh well.&lt;/p&gt;
&lt;h1 id="saving-things-for-later"&gt;Saving things for later&lt;/h1&gt;
&lt;p&gt;This is an almost shameful habit, but I tend to just use Telegram's 'Saved Messages' feature to save most quick thought and notes as well as forwarding links or bits of conversation to myself. Furthermore, I send myself quite a few screenshots from pages or posts I'd like to come back to but can't easily get a link to. This extends over to other social media as well where I'll often save Reddit, Mastodon, etc. posts so that I can build up a 'get to it later' pile to hammer through in one sitting. While I'm not necessarily recomending this workflow it does work well enough for me, espically since I can forward messages from most people back to myself as I do the majority of my texting through Telegram.&lt;/p&gt;
&lt;h1 id="to-many-hobbies-not-enough-space"&gt;To many hobbies, not enough space&lt;/h1&gt;
&lt;p&gt;To me, there's this sort of evil, pick 2 triangle of 'Ergonomics V Space V Cost' question for most purchases. You see, I have a lot of hobbies: I play a pile of different instruments, skateboard, do some martial arts, work with electronics, program, PC Game, mess with Ham Radio, do some digital art, read... You get the idea. Each additional hobby takes up space. I'm by no means attempting to live in a 'tiny home' but I do have to many things. This is of dramatic impact on my workflow as it can be incredibly time consuming to setup or take down all of my music gear (audio interface, MIDI devices, effects pedals, synths, etc.) so that I can hook up my electrical lab (PSU, Scope, Meter, Dev boards, etc.) So, for the most part, both have to co-exist on my desk to some extent- even more so when I'm doing electrical work that involves sound. This has lead me to the conclusion that there's a constant battle between space, ergonomics, and cost. Something like a MIDI keyboard is a great example: small, cheap keyboards exist but are incredibly limiting. Large, cheap keyboards also exist but are a pain to store. Multiple smaller keyboards (I mostly actually end up splitting the board to play two things at once) exist, but that's expensive. The same idea goes for having an easy to sort through electronics storage system, having a decent digital drawing tablet, or even something as simple as the speakers used for listening to music. I've been attempting to give careful thought to a few questions before I get anything 'is this significantly easier to use than a digital equivalent?', 'will I use it often enough to justify the space it takes up', 'can it do something I can't do with something else?', and 'How complex is it to setup/take down?' For example: The Rigol oscilloscope I own can do a much better job than most any USB scope, doesn't risk frying my computer, has a comfortable user interface (real knobs), and only really needs a power cord; however, it does take up much more space than a USB scope and it's relatively large size necessitates a fair amount of room for it be available on my desk. To me, the pros outweighed the cons. On the flipside, I recently decided I'd like to add some Hurdy Gurdy and Lute sounds to my music: buying physical instruments would mean I'd have to first get over the learning curve to be proficient at playing them, I'd have to find a place to store them, and I'd have to pay upwards of $700 minimum to get reasonable quality versions of both. So, instead I purchased two virtual instruments that give me pretty nice Gurdy and Lute sounds while only requiring I have a high level knowledge of how the instrument functions and letting me use my existing MIDI controllers. I do lose out on some sonic possibilities, and, admittedly, it's less fun to play, but I deemed that a low price to pay for the convenience. Finally, from a sheer ergonomic perspective some things need to be considered. Realistically, from a space and cost perspective having multiple monitors is all around bad, but the massive advantage in ergonomics and workflow is well worth the cost to me.&lt;/p&gt;
&lt;h1 id="wrapping-up"&gt;Wrapping Up&lt;/h1&gt;
&lt;p&gt;I hope at least some of this was interesting and/or helpful to you. If you have any questions or comments as always feel free to send me a PM on telegram @Vegadeftwing&lt;/p&gt;
&lt;p&gt;I'll probably be updating this same blog post from time to time, adding to or changing things as the way I work ever evolves, so if that's something that interests you, you may want to check back to this in the future.&lt;/p&gt;
&lt;p&gt;I'd also love to hear what you do differently and why, I'd even gladly share it on this blog.&lt;/p&gt;</content><category term="Blog"></category><category term="Workflow"></category><category term="Blog"></category></entry></feed>